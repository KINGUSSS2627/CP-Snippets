{
	"troll": {
		"prefix": "troll",
		"body": [
		  "// Assembly Generator: gcc -S -o temp.s fileName.cpp",
		  "// Executable: gcc -o temp.exe fileName.cpp",
		  "#define assembler(x) __asm__(R\"(x)\");",
		  "// real source - "
		],
		"description": "troll"
	},
	"bp": {
		"prefix": "bp",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#ifndef ONLINE_JUDGE",
		  "#include \"debug.h\"",
		  "#else",
		  "#define dbg(x...)",
		  "#endif",
		  "",
		  "using namespace std;",
		  "",
		  "#define ll long long int",
		  "#define spr(x) for(int i=1; i<=n; i++) cout<<x[i]<<' ';",
		  "",
		  "const long long m = 1e9+7;",
		  "const int maxn = 3e5 + 69;",
		  "",
		  "void pre_process(){",
		  "    ",
		  "}",
		  "",
		  "int solve(){",
		  "    int n; cin>>n;",
		  "    dbg(n);",
		  "    return 2*n; ",
		  "}",
		  "int32_t main(){",
		  "    ios_base::sync_with_stdio(0);",
		  "    cin.tie(0); cout.tie(0);",
		  "    pre_process();",
		  "    int t; cin>>t;",
		  "    while(t--) cout<<solve()<<'\\n';",
		  "}"
		],
		"description": "bp"
	},
	"pq": {
		"prefix": "pq",
		"body": [
		  "priority_queue<int> pq;",
		  "priority_queue<int, vector<int>, greater<>> pq;"
		],
		"description": "pq"
	},
	"fac": {
		"prefix": "fac",
		"body": [
		  "int fac[maxn];",
		  "int inv[maxn];",
		  "fac[1] = inv[1] = 1;",
		  "for (int i=2; i<maxn; i++){",
		  "  fac[i] = (fac[i-1] * i)%mod;",
		  "  inv[i] = power(fac[i], mod - 2);",
		  "}",
		  ""
		],
		"description": "fac"
	},
	"combination": {
		"prefix": "combination",
		"body": [
		  "int C(int n, int r){",
		  "    int v = (fac[n] * inv[r])%mod;",
		  "    v = (v * inv[n-r])%mod;",
		  "    ",
		  "    return v;",
		  "}",
		  ""
		],
		"description": "combination"
	},
	"arr-inp": {
		"prefix": "arr-inp",
		"body": [
		  "vector<int> a(n, 0);",
		  "for(int i=0;i<n;i++) cin>>a[i];"
		],
		"description": "arr-inp"
	},
	"arr-pref": {
		"prefix": "arr-pref",
		"body": [
		  "vector<int> pre(n, 0);",
		  "for(int i=1;i<n;i++) pre[i]=a[i]+pref[i-1]; "
		],
		"description": "arr-pref"
	},
	"recur-modpow": {
		"prefix": "recur-modpow",
		"body": [
		  "int power(int x, int y){",
		  "    if (y==0) return 1;",
		  "    ",
		  "    int v = power(x, y/2);",
		  "    v *= v;",
		  "    v %= mod;",
		  "    if (y&1) return (v*x)%mod;",
		  "    else return v;",
		  "}",
		  ""
		],
		"description": "recur-modpow"
	},
	"pbds" : {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<int, null_type, less_equal<int>, rb_tree_tag, tree_order_statistics_node_update> op_set;\n"
		],
		"description": "pbds"
	},
	"binpow": {
		"prefix": "binpow",
		"body": [
		  "ll binpow(ll x, ll y){",
		  "    ll res = 1;",
		  "    while (y>0){",
		  "        if (y&1) res = (ll)(res*x);",
		  "        y = y>>1;",
		  "        x = (ll)(x*x);",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "binpow"
	},
	"modpow": {
		"prefix": "modpow",
		"body": [
		  "ll modpow(ll a, ll b){",
		  "    a %= m;",
		  "    ll res = 1;",
		  "    while (b > 0) {",
		  "        if (b & 1) res = res * a % m;",
		  "        a=a*a%m;",
		  "        b>>=1;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "modpow"
	},
	"mint": {
		"prefix": "mint",
		"body": [
		  "struct mi {",
		  "    int64_t v; explicit operator int64_t() const { return v % mod; }",
		  "    mi() { v = 0; }",
		  "    mi(int64_t _v) {",
		  "        v = (-mod < _v && _v < mod) ? _v : _v % mod;",
		  "        if (v < 0) v += mod;",
		  "    }",
		  "    friend bool operator==(const mi& a, const mi& b) {",
		  "        return a.v == b.v; }",
		  "    friend bool operator!=(const mi& a, const mi& b) {",
		  "        return !(a == b); }",
		  "    friend bool operator<(const mi& a, const mi& b) {",
		  "        return a.v < b.v; }",
		  "",
		  "    mi& operator+=(const mi& m) {",
		  "        if ((v += m.v) >= mod) v -= mod;",
		  "        return *this; }",
		  "    mi& operator-=(const mi& m) {",
		  "        if ((v -= m.v) < 0) v += mod;",
		  "        return *this; }",
		  "    mi& operator*=(const mi& m) {",
		  "        v = v*m.v%mod; return *this; }",
		  "    mi& operator/=(const mi& m) { return (*this) *= inv(m); }",
		  "    friend mi pow(mi a, int64_t p) {",
		  "        mi ans = 1; assert(p >= 0);",
		  "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
		  "        return ans;",
		  "    }",
		  "    friend mi inv(const mi& a) { assert(a.v != 0);",
		  "        return pow(a,mod-2); }",
		  "",
		  "    mi operator-() const { return mi(-v); }",
		  "    mi& operator++() { return *this += 1; }",
		  "    mi& operator--() { return *this -= 1; }",
		  "    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }",
		  "    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }",
		  "    friend mi operator+(mi a, const mi& b) { return a += b; }",
		  "    friend mi operator-(mi a, const mi& b) { return a -= b; }",
		  "    friend mi operator*(mi a, const mi& b) { return a *= b; }",
		  "    friend mi operator/(mi a, const mi& b) { return a /= b; }",
		  "    friend ostream& operator<<(ostream& os, const mi& m) {",
		  "        os << m.v; return os;",
		  "    }",
		  "    friend istream& operator>>(istream& is, mi& m) {",
		  "        int64_t x; is >> x;",
		  "        m.v = x;",
		  "        return is;",
		  "    }",
		  "    friend void __print(const mi &x) {",
		  "        cerr << x.v;",
		  "    }",
		  "};",
		  ""
		],
		"description": "mint"
	  },
	  "seive": {
		"prefix": "seive",
		"body": [
		  "vector<bool> Prime;",
		  "vector<int> spf;",
		  "void sieve(int s = maxn) {",
		  "    Prime.resize(s + 1, 1);",
		  "    spf.resize(s + 1, s + 1);",
		  "    for(int i = 2 ; i <= s ; i++)   if(Prime[i]) {",
		  "        spf[i] = min(spf[i], i);",
		  "        for(int j = i ; (ll)j * i <= s ; j++)",
		  "            Prime[j * i] = 0, spf[j * i] = min(i, spf[j * i]);",
		  "    }",
		  "}",
		  ""
		],
		"description": "seive"
	  }
}
