{
	"bp": {
		"prefix": "bp",
		"body": [
		  "#include <bits/stdc++.h>",
		  "#ifndef ONLINE_JUDGE",
		  "#include \"debug.h\"",
		  "#pragma GCC optimize(\"O3,unroll-loops\")",
		  "#pragma GCC target(\"avx2,bmi,bmi2,lzcnt,popcnt\")",
		  "#else",
		  "#define dbg(x...) \"11-111\"",
		  "#endif",
		  "",
		  "using namespace std;",
		  "",
		  "#define ll long long int",
		  "#define int long long int // because mai bevakoof hu",
		  "#define spr(x) for(int i=1; i<=n; i++) cout<<x[i]<<' ';",
		  "#define gcd(a,b) __gcd(a,b)",
		  "#define lcm(a,b) (a*b)/__gcd(a,b)",
		  "",
		  "constexpr ll Inf = 4e18;",
		  "constexpr int mod = 1e9+7;",
		  "// constexpr int mod = 998244353;",
		  "constexpr int maxn = 1e6+5;",
		  "",
		  "void pre_process(){",
		  "    ",
		  "}",
		  "",
		  "int solve(){",
		  "    int n; cin>>n;",
		  "    dbg(n);",
		  "    return 2*n; ",
		  "}",
		  "int32_t main(){",
		  "    ios_base::sync_with_stdio(0);",
		  "    cin.tie(0); cout.tie(0);",
		  "    pre_process();",
		  "    int t; cin>>t;",
		  "    while(t--) cout<<solve()<<'\\n';",
		  "}"
		],
		"description": "bp"
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
		  "#include <ext/pb_ds/assoc_container.hpp>",
		  "#include <ext/pb_ds/tree_policy.hpp>",
		  "using namespace __gnu_pbds;",
		  "// pbds = find_by_value(), order_of_key()",
		  "template<class T> using minheap = priority_queue<T,vector<T>,greater<T> >; ",
		  "template<class T> using ordered_set = tree<T, null_type,less<T>, rb_tree_tag, tree_order_statistics_node_update> ;",
		  "template<class key, class value, class cmp = std::less<key>> using ordered_map = tree<key, value, cmp, rb_tree_tag, tree_order_statistics_node_update>;"
		],
		"description": "pbds"
	},
	"rng": {
		"prefix": "rng",
		"body": [
		  "//random generator",
		  "mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
		  "ll rnd(ll a,ll b){if(a > b){return -1;}return a + (ll)rng() % (b - a + 1);}"
		],
		"description": "rng"
	},
	"pq": {
		"prefix": "pq",
		"body": [
		  "priority_queue<int> pq;",
		  "priority_queue<int, vector<int>, greater<>> pq;"
		],
		"description": "pq"
	},
	"explanation_binsearch": {
		"prefix": "explanation_binsearch",
		"body": [
		  "int lo = 0, hi = n-1; // see constraints for lo and hi, nahi mil rahe toh just take 0 and 1e18",
		  "while(hi-lo>1) {",
		  "    int mid = lo + ((hi-lo) >> 1); // to avoid overflows",
		  "    // lo will become the last index that satisfies X condition",
		  "    // hi is the first element that doesn't satisfy X condition",
		  "    // lower_bound = < ",
		  "    // upper_bound = <=",
		  "    // upper using lower = lo, < + ek for loop to traverse the same till upper is obtained",
		  "        ",
		  "    // essence -> ",
		  "    // remember, lo ke left mai condition always true, lo last one jispe true",
		  "    // hi ke right mai condition always false, hi first one jispe false",
		  "    // hi will probably be the answer in most cases",
		  "    // hi+1, lo, lo-1 are also potential answers (maybe, mujhe toh bas lo and hi mile aaj tak)",
		  "",
		  "    // always make condition such that when it's true, left segment is eliminated as potential answer container",
		  "    // if condition true toh bas right segment mai search hoga, left eliminated",
		  "    auto check = [&](ll mid) {",
		  "        // this is where majority is what you wanna write happens",
		  "      return (/*condition here*/);",
		  "    };",
		  "    if(check(mid)){",
		  "        // do stuff here",
		  "        lo = mid;",
		  "    }",
		  "    else {",
		  "        hi = mid;",
		  "    }",
		  "}"
		],
		"description": "explanation_binsearch"
	},
	"binsearch": {
		"prefix": "binsearch",
		"body": [
		  "int lo = 0, hi = n-1;",
		  "while(hi-lo>1) {",
		  "    int mid = lo + ((hi-lo) >> 1);",
		  "    // if condition true toh bas right segment mai search hoga, left eliminated",
		  "    auto check = [&](ll mid) {",
		  "      return (/*condition here*/);",
		  "    };",
		  "    if(check(mid)){",
		  "        // do stuff here",
		  "        lo = mid;",
		  "    }",
		  "    else {",
		  "        hi = mid;",
		  "    }",
		  "}"
		],
		"description": "binsearch"
	},
	"lambda_function": {
		"prefix": "lambda_function",
		"body": [
		  "auto check = [&](ll mid) {",
		  "  return mid - (mid / n) >= k;",
		  "};"
		],
		"description": "lambda_function"
	},
	"fac": {
		"prefix": "fac",
		"body": [
		  "int fac[maxn];",
		  "int inv[maxn];",
		  "fac[1] = inv[1] = 1;",
		  "for (int i=2; i<maxn; i++){",
		  "  fac[i] = (fac[i-1] * i)%mod;",
		  "  inv[i] = power(fac[i], mod - 2);",
		  "}",
		  ""
		],
		"description": "fac"
	},
	"combination": {
		"prefix": "combination",
		"body": [
		  "int C(int n, int r){",
		  "    int v = (fac[n] * inv[r])%mod;",
		  "    v = (v * inv[n-r])%mod;",
		  "    ",
		  "    return v;",
		  "}",
		  ""
		],
		"description": "combination"
	},
	"combination-non-mod": {
		"prefix": "combination-non-mod",
		"body": [
		  "vector<vector<int>> dp(n+1, vector<int> (k+1));",
		  "int binomalCoeff(int n, int k){",
		  "    for (int i=0; i<=n; i++){",
		  "        for (int j=0; j<=k; j++){",
		  "             if (!j || j == i) dp[i][j] = 1;",
		  "             // binomial coefficient approach",
		  "             else dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];",
		  "         }",
		  "     }",
		  "     return dp[n][k];",
		  "}"
		],
		"description": "combination-non-mod"
	},
	"factorization": {
		"prefix": "factorization",
		"body": [
		  "void printFactors(int n) { ",
		  "    for (int i=1; i * i<=n; i++){} ",
		  "        if (n%i == 0) { ",
		  "            if (n/i == i) cout << i << \" \"; ",
		  "            else cout << i << \" \" << n/i << \" \"; ",
		  "        } ",
		  "    }",
		  "    cout << \"\\n\";",
		  "} ",
		  "",
		  "void printPrimeFactors(int n){",
		  " set<int> f;",
		  " for (int i = 2; i*i <= n; i++){",
		  "     while (n % i == 0){",
		  "         f.insert(i);",
		  "         n /= i;",
		  "      }",
		  " }",
		  " for (auto &i : f){",
		  "     cout << i << \" \";",
		  " }",
		  " cout << \"\\n\";",
		  "}",
		  ""
		],
		"description": "factorization"
	},
	"DSU": {
		"prefix": "DSU",
		"body": [
		  "class DSU {",
		  "private:",
		  "    vector<int> parent, size;",
		  "public:",
		  "    DSU(int n) {",
		  "        parent = vector<int>(n);",
		  "        size = vector<int>(n, 1);",
		  "        iota(begin(parent), end(parent), 0);",
		  "    }",
		  "    ",
		  "    int getParent(int x) {",
		  "        if (parent[x] == x) return x;",
		  "        return parent[x] = getParent(parent[x]);",
		  "    }",
		  "",
		  "    void join(int x, int y) {",
		  "        x = getParent(x);",
		  "        y = getParent(y);",
		  "        if (size[x] > size[y])",
		  "            swap(x, y);",
		  "        if (x == y) return;",
		  "        parent[x] = y;",
		  "        size[y] += size[x];",
		  "    }",
		  "",
		  "    int getSize(int x) {",
		  "        return size[x] = size[getParent(x)];",
		  "    }",
		  "};"
		],
		"description": "DSU"
	},
	"kruskal": {
		"prefix": "kruskal",
		"body": [
		  "auto kruskalMST(vector<Edge> &edges, int V){",
		  "    int cost = 0;",
		  "    DSU dsu(V);",
		  "    sort(begin(edges), end(edges));",
		  "    vector<Edge> tree;",
		  "    for (const auto &[u, v, w] : edges){",
		  "        if (dsu.getParent(u) != dsu.getParent(v)) {",
		  "            cost += w;",
		  "            tree.emplace_back(u, v, w);",
		  "            dsu.join(u, v);",
		  "        }",
		  "    }",
		  "    return make_pair(tree, cost);",
		  "}",
		  ""
		],
		"description": "kruskal"
	},
	"kosaraju": {
		"prefix": "kosaraju",
		"body": [
		  "class Graph {",
		  " int V;",
		  " vector<int> *adj;",
		  "",
		  " void fillOrder(int v, bool visited[], stack<int> &s);",
		  "",
		  " void dfsUtil(int v, bool visited[]);",
		  "",
		  "public:",
		  " Graph(int V) : V(V)",
		  " {",
		  "   adj = new vector<int>[V];",
		  " }",
		  " ~Graph()",
		  " {",
		  "    delete[] adj;",
		  " }",
		  "",
		  " void addEdge(int v, int w);",
		  "",
		  " void printSCCs();",
		  "",
		  " Graph getTranspose();",
		  "};",
		  "",
		  "void Graph::dfsUtil(int v, bool visited[]) {",
		  " visited[v] = true;",
		  " cout << v <<  \" \";",
		  " for (auto &it : adj[v])",
		  "     if (!visited[it])",
		  "        dfsUtil(it, visited);",
		  "}",
		  "",
		  "Graph Graph::getTranspose() {",
		  " Graph g(V);",
		  " for (int i = 0; i < V; i++) {",
		  "     for (auto &it : adj[i])",
		  "         g.adj[it].push_back(i);",
		  " }",
		  " return g;",
		  "}",
		  "",
		  "void Graph::addEdge(int v, int w) {",
		  " adj[v].push_back(w);",
		  "}",
		  "",
		  "void Graph::fillOrder(int v, bool visited[], stack<int> &s) {",
		  " visited[v] = true;",
		  " for (auto &it : adj[v])",
		  "     if (!visited[it])",
		  "         fillOrder(it, visited, s);",
		  " s.push(v);",
		  "}",
		  "",
		  "void Graph::printSCCs() {",
		  " stack<int> s;",
		  " bool visited[V] = {0};",
		  " for (int i = 0; i < V; i++)",
		  "      if (!visited[i])",
		  "        fillOrder(i, visited, s);",
		  "",
		  " Graph gr = getTranspose();",
		  " for (int i = 0; i < V; i++)",
		  "     visited[i] = false;",
		  "",
		  " while (!s.empty()) {",
		  "     int v = s.top();",
		  "     s.pop();",
		  "     if (!visited[v]){",
		  "        gr.dfsUtil(v, visited);",
		  "        cout << \"\\n\";",
		  "     }",
		  " }",
		  "}"
		],
		"description": "kosaraju"
	},
	"LCA path satisfying some condition": {
		"prefix": "lca",
		"body": [
		  "constexpr int N = 5; // No. of vertices",
		  "constexpr int L = 4; // ceil(logN / log2) + 1",
		  "",
		  "// Vertices from 1 to N.",
		  "vector<int> adj[N + 1];",
		  "int up[N + 1][L];",
		  "int level[N + 1];",
		  "",
		  "void dfs(int u, int prev = 0){",
		  " up[u][0] = prev;",
		  " for (auto &v : adj[u]){",
		  "     if (v == prev) continue;",
		  "",
		  "     level[v] = level[u] + 1;",
		  "     dfs(v, u);",
		  " }",
		  "}",
		  "",
		  "void binaryLift(){",
		  " dfs(1);",
		  " for (int i = 1; i < L; i++)",
		  "     for (int j = 1; j <= N; j++)",
		  "          up[j][i] = up[up[j][i - 1]][i - 1];",
		  "}",
		  "",
		  "int LCA(int a, int b){",
		  " if (level[a] > level[b])",
		  "     swap(a, b);",
		  "",
		  " int diff = level[b] - level[a];",
		  " for (int i = 0; i < L; i++){",
		  "     if ((diff & (1 << i)))",
		  "         b = up[b][i];",
		  " }",
		  "",
		  " if (a == b) return a;",
		  "",
		  " for (int i = L - 1; i >= 0; i--){",
		  "     if (up[a][i] != up[b][i]){",
		  "         a = up[a][i];",
		  "         b = up[b][i];",
		  "     }",
		  " }",
		  " return up[a][0];",
		  "}",
		  "",
		  "void addEdge(int u, int v){",
		  " adj[u].push_back(v);",
		  " adj[v].push_back(u);",
		  "}",
		  "",
		  "int dist(int a, int b){",
		  " return level[a] + level[b] - 2 * level[LCA(a, b)];",
		  "}",
		  ""
		],
		"description": "LCA path satisfying some condition"
	},
	"combination-small": {
		"prefix": "combination-small",
		"body": [
		  "int C(int n,int r){",
		  "    r = min(r,n-r);",
		  "    int ans = 1;",
		  "    for(int i=1;i<=r;i++,n--){",
		  "        ans *=n;",
		  "        ans/=i;",
		  "    }",
		  "    return ans;",
		  "}",
		  ""
		],
		"description": "combination-small"
	},
	"arr-inp": {
		"prefix": "arr-inp",
		"body": [
		  "vector<int> a(n, 0);",
		  "for(int i=0;i<n;i++) cin>>a[i];"
		],
		"description": "arr-inp"
	},
	"arr-pref": {
		"prefix": "arr-pref",
		"body": [
		  "vector<int> pre(n, 0);",
		  "for(int i=1;i<n;i++) pre[i]=a[i]+pref[i-1]; "
		],
		"description": "arr-pref"
	},
	"recur-modpow": {
		"prefix": "recur-modpow",
		"body": [
		  "int power(int x, int y){",
		  "    if (y==0) return 1;",
		  "    ",
		  "    int v = power(x, y/2);",
		  "    v *= v;",
		  "    v %= mod;",
		  "    if (y&1) return (v*x)%mod;",
		  "    else return v;",
		  "}",
		  ""
		],
		"description": "recur-modpow"
	},
	"binpow": {
		"prefix": "binpow",
		"body": [
		  "ll binpow(ll x, ll y){",
		  "    ll res = 1;",
		  "    while (y>0){",
		  "        if (y&1) res = (ll)(res*x);",
		  "        y = y>>1;",
		  "        x = (ll)(x*x);",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "binpow"
	},
	"modpow": {
		"prefix": "modpow",
		"body": [
		  "ll modpow(ll a, ll b){",
		  "    a %= m;",
		  "    ll res = 1;",
		  "    while (b > 0) {",
		  "        if (b & 1) res = res * a % m;",
		  "        a=a*a%m;",
		  "        b>>=1;",
		  "    }",
		  "    return res;",
		  "}"
		],
		"description": "modpow"
	},
	"mint": {
		"prefix": "mint",
		"body": [
		  "struct mi {",
		  "    int64_t v; explicit operator int64_t() const { return v % mod; }",
		  "    mi() { v = 0; }",
		  "    mi(int64_t _v) {",
		  "        v = (-mod < _v && _v < mod) ? _v : _v % mod;",
		  "        if (v < 0) v += mod;",
		  "    }",
		  "    friend bool operator==(const mi& a, const mi& b) {",
		  "        return a.v == b.v; }",
		  "    friend bool operator!=(const mi& a, const mi& b) {",
		  "        return !(a == b); }",
		  "    friend bool operator<(const mi& a, const mi& b) {",
		  "        return a.v < b.v; }",
		  "",
		  "    mi& operator+=(const mi& m) {",
		  "        if ((v += m.v) >= mod) v -= mod;",
		  "        return *this; }",
		  "    mi& operator-=(const mi& m) {",
		  "        if ((v -= m.v) < 0) v += mod;",
		  "        return *this; }",
		  "    mi& operator*=(const mi& m) {",
		  "        v = v*m.v%mod; return *this; }",
		  "    mi& operator/=(const mi& m) { return (*this) *= inv(m); }",
		  "    friend mi pow(mi a, int64_t p) {",
		  "        mi ans = 1; assert(p >= 0);",
		  "        for (; p; p /= 2, a *= a) if (p&1) ans *= a;",
		  "        return ans;",
		  "    }",
		  "    friend mi inv(const mi& a) { assert(a.v != 0);",
		  "        return pow(a,mod-2); }",
		  "",
		  "    mi operator-() const { return mi(-v); }",
		  "    mi& operator++() { return *this += 1; }",
		  "    mi& operator--() { return *this -= 1; }",
		  "    mi operator++(int32_t) { mi temp; temp.v = v++; return temp; }",
		  "    mi operator--(int32_t) { mi temp; temp.v = v--; return temp; }",
		  "    friend mi operator+(mi a, const mi& b) { return a += b; }",
		  "    friend mi operator-(mi a, const mi& b) { return a -= b; }",
		  "    friend mi operator*(mi a, const mi& b) { return a *= b; }",
		  "    friend mi operator/(mi a, const mi& b) { return a /= b; }",
		  "    friend ostream& operator<<(ostream& os, const mi& m) {",
		  "        os << m.v; return os;",
		  "    }",
		  "    friend istream& operator>>(istream& is, mi& m) {",
		  "        int64_t x; is >> x;",
		  "        m.v = x;",
		  "        return is;",
		  "    }",
		  "    friend void __print(const mi &x) {",
		  "        cerr << x.v;",
		  "    }",
		  "};",
		  ""
		],
		"description": ""
	  },
	  "seive": {
		"prefix": "seive",
		"body": [
		  "vector<bool> Prime;",
		  "vector<int> spf;",
		  "void sieve(int s = maxn) {",
		  "    Prime.resize(s + 1, 1);",
		  "    spf.resize(s + 1, s + 1);",
		  "    for(int i = 2 ; i <= s ; i++)   if(Prime[i]) {",
		  "        spf[i] = min(spf[i], i);",
		  "        for(int j = i ; (ll)j * i <= s ; j++)",
		  "            Prime[j * i] = 0, spf[j * i] = min(i, spf[j * i]);",
		  "    }",
		  "}",
		  ""
		],
		"description": "seive"
	},
	"derangments": {
		"prefix": "derangments",
		"body": [
		  "int countDerangements(int n){",
		  "    int dp[n + 1];",
		  "    if (n < 3) return (dp[n]=(n % 2)?1:0);",
		  "    dp[0] = 1, dp[1] = 0, dp[2] = 1;",
		  "    for (int i=3; i< n; i++) dp[i] = (i-1)*(dp[i-1]+dp[i-2]);",
		  "    return dp[n];",
		  "}"
		],
		"description": "derangments"
	},
	"euclid": {
		"prefix": "euclid",
		"body": [
		  "int euclid_gcd(int a, int b){",
		  "    if (b==0) return a;",
		  "    return gcd(b, a % b);",
		  "}",
		  "",
		  "int euclid_gcdExtended(int a, int b, int *x, int *y){",
		  "    if (a == 0){",
		  "        *x = 0;",
		  "        *y = 1;",
		  "        return b;",
		  "    }",
		  "    int x1, y1;",
		  "    int gcd = gcdExtended(b % a, a, &x1, &y1);",
		  "    *x = y1 - (b / a) * x1;",
		  "    *y = x1;",
		  "    return gcd;",
		  "}",
		  "",
		  ""
		],
		"description": "euclid"
	},
	"easy_seive": {
		"prefix": "easy_seive",
		"body": [
		  "void ez_seive(int n){",
		  "     vector<bool> prime(n,1);",
		  "     for (int p = 2; p*p <= n; p++){",
		  "         if (prime[p]){",
		  "            for (int i = p * p; i <= n; i += p) prime[i] = false;",
		  "         }",
		  "     }",
		  "}",
		  "for (int p = 2; p <= n; p++){",
		  "      // do whatever you want with those primes${1}",
		  "      if (prime[p]) cout << p << \" \";",
		  "}",
		  ""
		],
		"description": "easy_seive"
	},
	"troll": {
		"prefix": "troll",
		"body": [
		  "// Assembly Generator: gcc -S -o temp.s fileName.cpp",
		  "// Executable: gcc -o temp.exe fileName.cpp",
		  "#define assembler(x) __asm__(R\"(x)\");",
		  "// real source - "
		],
		"description": "troll"
	}
}
